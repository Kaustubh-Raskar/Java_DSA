    Locks and Semaphores:

When multiple threads are using same object/resource then the object methods must use synchronized keyword.
Else
If Multiple Threads are working with Different objects or different instance of Objects then we have Custom Locks as below:
1. Re-Entrant Lock
2. Read Write
3. Semaphores
4. Stamped

-- Locking do not depend on Objects like synchronized method.
________________________________________________________________________________________________________

Reentrant Lock:

In this we have to make a ReentrantLock object to add a lock to method/task which will be used in different threads with different instance of same objects.
Example:

public class SharedResource{

    boolean isAvailable = false;
    
    public void producer(ReentrantLock rLock){

        try{
            rLock.lock();
            System.out.println("Lock acquired by: "+ Thread.currentThread().getName());
            isAvailable = true;
            Thread.sleep(4000);
        }
        catch(Exception e){

        }finally{
            rLock.unlock();
            System.out.println("Lock release by: " + Thread.currentThread().getName());
        }
    }
}
-----------------------------------------------
public class Main{
    public static void main(String[] args){

        ReentrantLock reentrantLock = new ReentrantLock();
        SharedResource resource1 = new SharedResource();
        Thread th1 = new Thread(() -> {
            resource1.producer(reentrantLock);
        });

        SharedResource resource2 = new SharedResource();
        Thread th2 = new Thread(() -> {
            resource2.producer(reentrantLock);
        });

        th1.start();
        th2.start();

    }
}

Ouput:
Lock acquired by: thread-0
Lock release by:  thread-0 
Lock acquired by: thread-1
Lock release by:  thread-1

Notes:
As we seen in above example, even if different object instance are used still method is being used synchronizly,
Only after thread-0 completes its Task then the resource gets unlocked for other thread to work.
________________________________________________________________________________________________________

ReadWrite Lock:

ReadLock (Shared Lock) - More than 1 thread can acquire the read lock
WriteLock (Exclusive Lock) - Only 1 thread can acquire the write lock

When to Use:
- When your read operations are very high in application and write operations are less

import java.util.concurrent.locks.ReadWriteLock;

public class SharedResource{

    boolean isAvailable = false;
    public void producer(ReadWriteLock lock){
        try{
            lock.readLock().lock();
            System.out.println("Read Lock acquired by: " + Thread.currentThread().getName());
            Thread.sleep(8000);
        }
        catch(Exception e){
            e.printStackTrace();
        }
        finally{
            lock.readLock().unlock();
            System.out.println("Read Lock release by: " + Thread.currentThread().getName());
        }
    }

    public void consumer(ReadWriteLock lock){
        try{
            lock.writeLock().lock();
            System.out.println("Write Lock acquired by: " + Thread.currentThread().getName());
            isAvailable = false;
        }catch(Exception e){
            e.printStackTrace();
        }
        finally{
            lock.writeLock().unlock();
            System.out.println("Write Lock release by: " + Thread.currentThread().getName());
        }
    }
} 

--------------------------------------------
public class Main{
    public static void main(String[] args){

        SharedResource resource = new SharedResource();
        ReadWriteLock lock = new ReentrantReadWriteLock();

        Thread th1 = new Thread(()->{
            resource.producer(lock);
        });

        Thread th2 = new Thread(()->{
            resource.producer(lock);
        });

        SharedResource resource1 = new SharedResource();
        Thread th3 = new Thread(() -> {
            resource1.consume(lock);
        });

        th1.start();
        th2.start();
        th3.start();
    }
}

Output:
ReadLock acquired by:  Thread-0
ReadLock acquired by:  Thread-1
ReadLock release by:  Thread-0
ReadLock release by:  Thread-1
WriteLock acquired by:  Thread-2
WriteLock release by:  Thread-2
________________________________________________________________________________________________________

StampedLock: 

Provides ReadWriteLock capability.
Provides Optimistic Lock functionality. (Means there is No lock acquired)

1. ReadWriteLock functionality:

Example:
public class SharedResource{

    boolean isAvailable = false;
    SharedLock lock = new StampedLock();

    public void producer(){
        try{
            lock.readLock().lock();
            System.out.println("Read Lock acquired by: " + Thread.currentThread().getName());
            Thread.sleep(8000);
        }
        catch(Exception e){
            e.printStackTrace();
        }
        finally{
            lock.unlockRead(stamp);
            System.out.println("Read Lock release by: " + Thread.currentThread().getName());
        }
    }

    public void consumer(){
        try{
            long stamp = lock.writeLock();
            System.out.println("Write Lock acquired by: " + Thread.currentThread().getName());
            isAvailable = false;
        }catch(Exception e){
            e.printStackTrace();
        }
        finally{
            lock.unlockWrite(stamp);
            System.out.println("Write Lock release by: " + Thread.currentThread().getName());
        }
    }
} 
--------------------------------------------
public class Main{
    public static void main(String[] args){

        SharedResource resource = new SharedResource();

        Thread th1 = new Thread(()->{
            resource.producer();
        });

        Thread th2 = new Thread(()->{
            resource.producer();
        });

        SharedResource resource1 = new SharedResource();
        Thread th3 = new Thread(() -> {
            resource1.consume();
        });

        th1.start();
        th2.start();
        th3.start();
    }
}
--------------------------------------------------------------------
2. Using Optimistic Lock functionality too
Optimistic reads are for read-only critical sections that you later validate; if invalid, you re-read (or retry).

public class SharedResource{
    boolean isAvailable = false;
    StampedLock slock = new StampedLock();

    public void producer(){
        long stamp = slock.tryOptimisticRead();
        try{
            System.out.println("Taken Optimistic lock");
            a = 11;
            Thread.sleep(6000);

            if(!slock.validate(stamp)){
                System.out.println("Updated a value successfully");
            }else{
                System.out.println("Rollback of work");
                a = 10; // Rollback
            }
        }catch(Exception e){

        }
    }

    public void consumer(){
        long stamp = slock.writeLock();
        System.out.println("Write lock acquired by: " + Thread.currentThread().getName());

        try{
            System.out.println("Performing work");
            a = 9;
        }
        finally{
            slock.unlockWrite(stamp);
            System.out.println("Write lock released by : " +  Thread.currentThread().getName());
        }
    }
}
----------------------------------------------------------
public class Main{
    public static void main(String[] args){
        SharedResource resource = new SharedResource();

        Thread th1 = new Thread(() -> {
            resource.producer();
        });

        Thread th2 = new Thread(() -> {
            resource.consumer();
        });

        th1.start();
        th2.start();
    }
}
Output:
Taken Optimistic lock
Write lock acquired by: Thread-1
Performing work
Write lock released by : Thread-1
Rollback of work

Explanation:
th1 (producer): takes optimistic read, prints ‚ÄúTaken Optimistic lock‚Äù, 
sets a = 11, sleeps 6s.
th2 (consumer): acquires writeLock, prints, sets a = 9, releases.
th1 wakes and calls validate(stamp): this returns false (a write happened),
so it prints ‚ÄúRollback of work‚Äù and sets a = 10.
________________________________________________________________________________________________________

Semaphore Lock:
A semaphore maintains a set of permits.

Threads acquire a permit before entering a critical section, and release it when leaving.
If no permits are available ‚Üí threads are blocked until one is released.
Think of it as a parking lot with limited spaces:
    Cars (threads) can only enter if a space (permit) is free.
    When a car leaves, it frees up a space for another car.
Usecase:
Use Semaphore when you want to control how many threads can access a resource at the same time.
---------------------------------------------------------------------------------------------------
Types of Semaphores

Binary Semaphore (1 permit):
    Works like a simple lock (similar to synchronized or ReentrantLock).
    At most one thread can access at a time.

Counting Semaphore (N permits):
    Allows up to N threads to access concurrently.
    Useful for throttling, limiting resources, or connection pools.

----------------------------------------------------------------------------------------------------
Fair Locks:

By default, Semaphore is unfair (whoever comes first isn‚Äôt guaranteed to get the permit).

You can make it fair by:
Semaphore sem = new Semaphore(3, true); // fair
----------------------------------------------------------
Example:
import java.util.concurrent.Semaphore;

class ConnectionPool {
    private final Semaphore semaphore = new Semaphore(5);

    public void accessConnection() {
        try {
            semaphore.acquire();
            System.out.println(Thread.currentThread().getName() + " acquired connection.");
            Thread.sleep(2000); // simulate query execution
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            semaphore.release();
            System.out.println(Thread.currentThread().getName() + " released connection.");
        }
    }
}

public class SemaphoreExample {
    public static void main(String[] args) {
        ConnectionPool pool = new ConnectionPool();

        for (int i = 0; i < 10; i++) {
            new Thread(pool::accessConnection, "Thread-" + i).start();
        }
    }
}

Output (at most 5 threads work at once):
    Thread-0 acquired connection.
    Thread-1 acquired connection.
    Thread-2 acquired connection.
    Thread-3 acquired connection.
    Thread-4 acquired connection.
    Thread-0 released connection.
    Thread-5 acquired connection.
    ...

________________________________________________________________________________________________________
2. Producer‚ÄìConsumer with Bounded Buffer

Use two semaphores:
    One counting empty slots.
    One counting full slots.
    Ensures producer doesn‚Äôt overfill and consumer doesn‚Äôt over-consume.

3. Resource Throttling (API Calls, File Access)

Example: 
limit only 3 threads at a time to download files from an external service, to avoid overwhelming the server.
_______________________________________________________________________________________________________________________

Condition: java.util.concurrent.locks.Condition

For ReentrantLock, ReadWriteLock, StampedLock and Semaphore we have to use await() instead of wait() and signal() instead of notify()

Example:
    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();

üîπ await()
    Similar to wait().
    The calling thread:
    Must hold the lock.
    Releases the lock temporarily.
    Goes into WAITING state until signalled.
    Re-acquires the lock before resuming.

üîπ signal() / signalAll()
    Similar to notify() / notifyAll().
    Used by another thread (holding the same lock) to wake up one (or all) threads waiting on that condition.
    Woken threads must re-acquire the lock before continuing.

Example: Producer‚ÄìConsumer with Condition

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class SharedResource {
    private boolean itemAvailable = false;
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();

    public void produce() throws InterruptedException {
        lock.lock();
        try {
            while (itemAvailable) {
                condition.await(); // wait until consumer consumes
            }
            System.out.println(Thread.currentThread().getName() + " produced item");
            itemAvailable = true;
            condition.signal(); // wake up one waiting consumer
        } finally {
            lock.unlock();
        }
    }

    public void consume() throws InterruptedException {
        lock.lock();
        try {
            while (!itemAvailable) {
                condition.await(); // wait until producer produces
            }
            System.out.println(Thread.currentThread().getName() + " consumed item");
            itemAvailable = false;
            condition.signal(); // wake up producer
        } finally {
            lock.unlock();
        }
    }
}

public class ConditionExample {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        Thread producer = new Thread(() -> {
            try {
                for (int i = 0; i < 3; i++) {
                    resource.produce();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Producer");

        Thread consumer = new Thread(() -> {
            try {
                for (int i = 0; i < 3; i++) {
                    resource.consume();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Consumer");

        producer.start();
        consumer.start();
    }
}

Output:
    Producer produced item
    Consumer consumed item
    Producer produced item
    Consumer consumed item
    Producer produced item
    Consumer consumed item
________________________________________________________________________________________________________
üîπ Why Use Condition Instead of wait/notify?

Multiple conditions per lock:
With wait/notify, each object only has one implicit monitor condition.

With Condition, you can create multiple:
Condition notFull = lock.newCondition();
Condition notEmpty = lock.newCondition();

‚Üí This is how ArrayBlockingQueue works internally.

More explicit & readable:
await() and signal() are tied to the lock, so usage is clearer.

Avoids mistakes:
No need to synchronize on arbitrary objects.
________________________________________________________________________________________________________
‚úÖ In short:

await() ‚Üí wait until condition is met (releases lock, then reacquires later).
signal() ‚Üí wake up one waiting thread.
signalAll() ‚Üí wake up all waiting threads.

________________________________________________________________________________________________________
Example:
The classic use case where Condition is better than wait/notify: a bounded buffer with two separate conditions ‚Äî notFull and notEmpty.

üîπ Why Two Conditions?
    Producer should wait if the buffer is full ‚Üí use notFull.await().
    Consumer should wait if the buffer is empty ‚Üí use notEmpty.await().
    When producer adds ‚Üí signal consumers (notEmpty.signal()).
    When consumer removes ‚Üí signal producers (notFull.signal()).
This avoids spurious wakeups and prevents waking the wrong type of thread unnecessarily.

Code Example: Bounded Buffer with Conditions:
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class BoundedBuffer<T> {
    private final Queue<T> buffer = new LinkedList<>();
    private final int capacity;

    private final Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();

    public BoundedBuffer(int capacity) {
        this.capacity = capacity;
    }

    public void put(T item) throws InterruptedException {
        lock.lock();
        try {
            while (buffer.size() == capacity) {
                System.out.println(Thread.currentThread().getName() + " waiting: Buffer is full");
                notFull.await(); // wait until space is available
            }
            buffer.add(item);
            System.out.println(Thread.currentThread().getName() + " produced " + item);
            notEmpty.signal(); // signal consumer
        } finally {
            lock.unlock();
        }
    }

    public T take() throws InterruptedException {
        lock.lock();
        try {
            while (buffer.isEmpty()) {
                System.out.println(Thread.currentThread().getName() + " waiting: Buffer is empty");
                notEmpty.await(); // wait until item is available
            }
            T item = buffer.poll();
            System.out.println(Thread.currentThread().getName() + " consumed " + item);
            notFull.signal(); // signal producer
            return item;
        } finally {
            lock.unlock();
        }
    }
}

public class MultiConditionExample {
    public static void main(String[] args) {
        BoundedBuffer<Integer> buffer = new BoundedBuffer<>(3);

        // Producer
        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 6; i++) {
                    buffer.put(i);
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Producer");

        // Consumer
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 1; i <= 6; i++) {
                    buffer.take();
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Consumer");

        producer.start();
        consumer.start();
    }
}

Output:
Producer produced 1
Producer produced 2
Producer produced 3
Producer waiting: Buffer is full
Consumer consumed 1
Producer produced 4
Consumer consumed 2
Producer produced 5
Consumer consumed 3
Producer produced 6
Consumer consumed 4
Consumer consumed 5
Consumer consumed 6

üîπ Key Points

Two conditions:
notFull ‚Üí blocks producers when buffer is full.
notEmpty ‚Üí blocks consumers when buffer is empty.

Signal only the right type of thread:
Producer signals notEmpty after adding.
Consumer signals notFull after removing.

Much more efficient than wait/notify, where all threads wake up and then compete unnecessarily.

‚úÖ This is exactly how classes like ArrayBlockingQueue and LinkedBlockingQueue are implemented internally in java.util.concurrent.
_______________________________________________________________________________________________________________________________________________






































