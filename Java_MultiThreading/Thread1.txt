Process -
Process is an instance of a program that is getting executed.
It has its own resource like memory, Thread etc. OS allocate these resources to Process when its created.

Compilation: Generates bytecode that can be executed by JVM.
-> Execution: at this point JVM starts the new process, here Test is the class which has "public static void main(String args[]) method.

How much Memory does process gets?
While creating A new JVM instance will get created and we can tell how much heap memory to be allocated.
Every process gets its own Heap memory.

Thread -
Thread is known as Lightweight process.
or Smallest sequence of instructions that are executed by CPU independently.
- And 1 process can have multiple Thread.
- When a process is created, it starts with 1 Thread and that initial Thread known as 'Main Thread' and from that we can create multiple threads to perform
  task concurrently.

Thread.currentThread().getName()
_________________________________________________________________________________________________________________________________________________________________________

More on Process and Threads:

JVM has Heap and Stack and Code Segment, Data Segment, Registers, Program counters.
Whenever a Process is created a New JVM Instance is allocated to the Process.

Heap size allocation:
java -Xms256m -Xmx2g MainClassName

-Xms<size>: Min Heap Size
This will set the initial heap size, above, I allocated 256MB

-Xmx<size>: Max Heap Size
Max heap size, process can get, above I allocated 2GB, if tries to allocate more memory, "OutOfMemoryError" will occur.

Code Segment
- Contains the compiled BYTECODE (i.e.machine code) of the Java Program
- Its read only
- All threads within the same process, share the same code Segment.

Data Segment
- Contains the GLOBAL and STATIC variables
- All Threads within the same process, share the same data segment.
- Threads can read and modify the same data.
- Synchronization is required between multiple threads.

Heap
- Objects created at runtime using 'new' keyword are allocated in the heap
- Heap is shared among all the threads of the same process (but NOT WITHIN Process)
  (Let's say in Process1, X8000 heap memory pointing to same location in physical memory, same X8000 heap memory points to different location of process2)
- Threads can read and modify the heap data
- Synchronization is required between multiple Threads

Stack
- Each Thread has its own Stack
- It manages, method calls, local variables

Register
- When JIT(Just In Time) compiles converts the bytecode into native machine code, it uses Register
  to optimize the generated machine code.
- Also helps in context switching
- Each Thread has its own Register

Counter
- Also known as Program Counter, it points to the instruction which is getting executed.
- Increments its counter after successfully execution of the instruction.

All of the above are managed by JVM.
_________________________________________________________________________________________________________________________________________________________________________

MultiThreading -
- Allows a program to perform multiple task at the same time
- Multiple threads share the same resource such as memory space but still can perform task independently

Benefits:
- Task parallelism
- Responsiveness
- Resource Sharing

Challenges:
- Concurrency issue like deadlock, data inconsistency etc.
- Synchronized overhead
- Testing and Debugging is difficult
_________________________________________________________________________________________________________________________________________________________________________

Thread creation ways -
1. Using Runnable Interface
2. Extending Thread class

-------------------------------------------------------------------------------------------------------
1. Using Runnable Interface - (Mostly used methodology in India), also by Netflix.
- Thread class uses Runnable interface which contains run() method.
- Thread class then contains these methods: init(), run(), sleep(), start(), stop(), interrupt(), etc

- Another class which have some tasks that needs to be performed by Threads implements Runnable interface.
- Runnable class provide run() method which Thread invokes to execute the task
- Note: Class with Runnable Interface implemented is not a Thread.
- 
Example:

Step 1: Creating a class with Runnable to define task
public class MultiThreadingLearning implements Runnable{
    @Override
    public void run(){
        System.out.println("Code executed by thread: " + Thread.currentThread().getName());
    }
}

Step 2: Starting Thread to invoke run class from MultiThreading class
- Create an instance of class that implements Runnable (MultiThreadingLearning)
- Pass the Runnable object to the Thread constructor
- Start the Thread

public class Main{
    public static void main(String args[]){
        System.out.println("Going inside main method: " + Thread.currentThread.getName());
        MultiThreadingLearning runnableObj = new MultiThreadingLearning();
        Thread thread = new Thread(runnableObj);
        thread.start();
        System.out.println("Finish main method: " + Thread.currentThread().getName());
    }
}

Output:
Going inside main method: main
Finish main method: main
code executed by thread: Thread-0

Thread checks if runnableObj passed in constructor contains run method.
Note: Thread class constructor takes Runnable Object as parameter
------------------------------------------------------------------------------------------------------------------
2. Using extending Thread class

Directly extending MyClass() with Thread class which have tasks to be performed by Threads.

Class which extends Thread class, also becomes Thread or subclass of Thread.

Example:
Step 1: Create a Thread subclass
Creating a class with Thread

public class MultiThreadingLearning implements Thread{
    @Override
    public void run(){
        System.out.println("Code executed by thread: " + Thread.currentThread().getName());
    }
}

Step 2: Initiate and Start the Thread
- Create an instance of the subclass
- Call the start() method to begin the execution

public class Main{
    public static void main(String args[]){
        // We don't need to create Thread class instance now and passing the object to it.
        // As MultiThreadingLearning class already supporting Thread class
        System.out.println("Going inside main method: " + Thread.currentThread.getName());
        MultiThreadingLearning myThread = new MultiThreadingLearning();
        myThread.start();       // Now object can Directly use Thread methods without seprately 
        System.out.println("Finish main method: " + Thread.currentThread().getName());
    }
}
Output:
Going inside main method: main
Finish main method: main
code executed by thread: Thread-0
_________________________________________________________________________________________________________________________________________________________________________

Java Thread Lifecycle

1. New (Created)

Thread object is created using new Thread().
Not yet started.

âž¡ï¸ Moves to Runnable when you call start().

2. Runnable (Waiting for CPU)

The thread is ready to run but waiting for CPU time.
Scheduler decides when it gets CPU.

âž¡ï¸ Moves to Running when the CPU is assigned.
âž¡ï¸ Can also move to Blocked, Waiting, or Timed Waiting depending on situation.

3. Running (Got CPU)

The thread is executing its run() method.

âž¡ï¸ Goes back to Runnable if yield() is called.
âž¡ï¸ Goes to Terminated when run() finishes.
âž¡ï¸ Can go to Waiting, Timed Waiting, or Blocked depending on operations like sleep(), wait(), join(), or I/O.

4. Blocked

The thread is waiting to acquire a lock or finish an I/O task.
If Thread wants to lock on a resource which is locked by other thread,it has to wait.
âž¡ï¸ Returns to Runnable once the lock is acquired or I/O is done.
Note: When the Thread goes to Blocked state It releases all the Monitor Locks.

5. Waiting

Thread is waiting indefinitely when we call wait() method, make it non runnable until another thread signals it using (notify() or notifyAll()).
âž¡ï¸ Returns to Runnable once notified.
Note: Releases all the Monitor Locks

6. Timed Waiting

Thread is waiting for a specific period of time (using sleep(milliseconds), join(milliseconds), or wait(milliseconds)).
âž¡ï¸ Returns to Runnable when the time expires or join completes.

Note: Do not releases Monitor Locks

7. Terminated (Dead)

The thread has finished executing.
Cannot be restarted.

******Summary Flow:

New â†’ (start()) â†’ Runnable â†’ (scheduler) â†’ Running â†’ (finish run()) â†’ Terminated
While Running, it may also move to Blocked, Waiting, or Timed Waiting, and then back to Runnable.
_________________________________________________________________________________________________________________________________________________________________________

MONITOR LOCK :

Every Java object has a built-in monitor lock (also called an intrinsic lock).
When a thread enters a synchronized block/method, it acquires the monitor lock of that object.
Other threads trying to enter a synchronized block on the same object are blocked until the lock is released.
It helps to make sure that only 1 Thread goes inside a particular section of code.

When 2 or more Threads are dependent on the same resource/object
Thread1 acquires a Monitor lock over the required resource and once Thread1 completes its task then the resource is released for other dependent Threads.

Example â€“ With Synchronization (Using Monitor Lock)

class Counter {
    private int count = 0;

    // synchronized ensures monitor lock is acquired before execution
    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}

public class MonitorLockExample {
    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();

        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        });

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Final Count: " + counter.getCount());
    }
}

ðŸ‘‰ Always prints 2000, because:

When t1 enters increment(), it locks the Counter object monitor.
t2 must wait until the lock is released.
Once t1 finishes, the lock is released, and t2 can proceed.

âš¡ Key Notes:

synchronized â†’ acquires and releases monitor lock automatically.
Locks are per object, not per method.
If one thread holds the lock, other threads are blocked until itâ€™s released.
Deadlocks can occur if multiple locks are mismanaged.
_________________________________________________________________________________________________________________________________________________________________________

Join() method:

What is join()?
    join() is a method in the Thread class.
    When one thread calls t.join() on another thread t, it tells the current thread:
    ðŸ‘‰ â€œWait here until thread t finishes execution.â€

Example Without join():-
    public class WithoutJoinExample {
        public static void main(String[] args) {
            Thread t1 = new Thread(() -> {
                for (int i = 1; i <= 5; i++) {
                    System.out.println("Thread 1: " + i);
                    try { Thread.sleep(500); } catch (InterruptedException e) {}
                }
            });

            t1.start();

            // Main thread continues immediately without waiting
            System.out.println("Main thread finished work!");
        }
    }

Possible Output:
    Main thread finished work!
    Thread 1: 1
    Thread 1: 2
    Thread 1: 3
    Thread 1: 4
    Thread 1: 5
-- Here, the main thread ends before t1 finishes.
________________________________________________________________________________________________________
Example With join()
    public class JoinExample {
        public static void main(String[] args) throws InterruptedException {
            Thread t1 = new Thread(() -> {
                for (int i = 1; i <= 5; i++) {
                    System.out.println("Thread 1: " + i);
                    try { Thread.sleep(500); } catch (InterruptedException e) {}
                }
            });

            t1.start();

            // Main thread waits until t1 finishes
            t1.join();

            System.out.println("Main thread finished after t1!");
        }
    }

âœ… Output:
    Thread 1: 1
    Thread 1: 2
    Thread 1: 3
    Thread 1: 4
    Thread 1: 5
    Main thread finished after t1!

-- Now, the main thread waits for t1 to finish before proceeding.
---------------------------------------------------------------------------------
ðŸ”¹ Overloaded Versions

join() â†’ Waits until the thread finishes.
join(long millis) â†’ Waits for at most millis time.
join(long millis, int nanos) â†’ Waits for a specific time (down to nanoseconds).

If the thread finishes earlier, the waiting thread continues immediately.

ðŸ”¹ Example: join(long millis)
public class JoinMillisExample {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                System.out.println("Thread 1: " + i);
                try { Thread.sleep(500); } catch (InterruptedException e) {}
            }
        });

        t1.start();

        // Main thread will wait at most 2000 ms (2 sec) for t1
        t1.join(2000);

        System.out.println("Main thread continues (even if t1 is not finished).");
    }
}

ðŸ”¹ Summary

join(long millis) = wait for either: (Main thread continues (even if t1 is not finished).)
The thread finishes OR
The given time expires 
Whichever happens first.
________________________________________________________________________________________________________

Realtime Example:

public class SharedResource{

    boolean itemAvailable false;

    //Synchronized put the monitor lock
    public synchronized void addItem(){
        itemAvailable = true;
        System.out.println("Item added by: " + Thread.currentThread().getName() + " and invoking all threads which are waiting");
        notifyAll();
    }

    public synchronized void consumeItem(){
        System.out.println("consumeItem method invoked by: " + Thread.currentThread().getName());

        // using while loop to avoid "spurious wake-up", sometimes because of system noise
        while(!itemAvailable){
            try{
                System.out.println("Thread " + Thread.currentThread().getName() + " is waiting now");
                wait(); // It releases the monitor lock
            } catch(Exception e){
                // handle Exception here
            }
        }

        System.out.println("Item consumed by: " + Thread.currentThread().getName());
        itemAvailable = false;
    }
}

public class ProduceTask implements Runnable{
    SharedResource sharedResource;

    ProduceTask(SharedResource resource){
        this.sharedResource = resource;
    }

    @Override
    public void run(){
        System.out.println("Producer thread: " + Thread.currentThread().getName());
        try{
            Thread.sleep(5000l);
        }catch(Exception e){
            // handle any Exception here
        }
        sharedResource.addItem();
    }
}

public class ConsumeTask implements Runnable{
    SharedResource sharedResource;

    ConsumeTask(SharedResource resource){
        this.sharedResource = resource;
    }

    @Override
    public void run(){
        System.out.println("Consumer thread: " + Thread.currentThread().getName());
        sharedResource.consumeItem();
    }
}

public class Main{
    public static void main(String[] args){

        System.out.println("Main Method Start");

        SharedResource sharedResource = new SharedResource();

        // producer thread
        Thread producerThread = new Thread(new ProduceTask(sharedResource));

        // consumer thread
        Thread consumerThread = new Thread(new ConsumeTask(sharedResource));

        // Thread is in Runnable state
        producerThread.start();
        consumerThread.start();

        System.out.println("Main method end");

    }
}

-- Console sequence:
    Main Method Start
    Main method end
    Producer thread: Thread-0
    Consumer thread: Thread-1
    consumeItem method invoked by: Thread-1
    Thread Thread-1 is waiting now
    ... ~5 seconds pass ...
    Item added by: Thread-0 and invoking all threads which are waiting
    Item consumed by: Thread-1
_________________________________________________________________________________________________________________________________________________________________________


















